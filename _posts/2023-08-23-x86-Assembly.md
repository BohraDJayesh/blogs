---
# layout: post
title:  "x86 Assembly, What the hell is it ?"
tags: ["Reverse Engineering", "x86 Assembly", "Binary", "Assembly"]
---

# Theory
x86 Assembly 101 consists of two main components: the Theory section, which covers all the essential theoretical concepts necessary to finally able to question ourselves and our existence, and the Labs section. In the Labs, we will learn hands-on demonstrations of the theory weâ€™ve learned and follow step-by-step tutorials for getting started.

## Introduction
This blog is for those who wants to get an idea or wants to get started in learning assembly language or can be helpful in their RE journey as well. I too am learning parellely with writing this blog so don't mind if i've oversimplified something or have said something too generic. I have plans to cover up those generic topic as well but have to complete this first. I've stated this previosuly many times in my blogs and i'm telling it again that **"I consider myself a beginner in everything, and I'll stay that way until I achieve something significant in this field."**. <br>
Before diving into what x86 assembly is, what does x86 mean, what other different types of architcture are, we will cover up the basics first starting from all the way back to ........... CPU Architecure.

## Memory
A typical program memory is seperated into sections which are - 
- Heap
- Stack
- Uninitialized & Initialized data ( global and static variable ) 
- text sections for storing machine instructions.

Let's talk about the two main sections of the memory - Heap & Stack.

### Heap
Heap is the segment where dynamic memory allocation usually takes place. Generally during runtime heap memory is allocated and is not deallocated by itself, instead we've to use language defined functions or methods to free the allocated memory. Memory allocated in heap can be expanded too unlike stack.

### Stack
The stack is another critical memory region in a computer's memory. It is used for managing function calls, local variables, and maintaining program execution context. The stack contains sections to store code, and global variabls. We will explore more about stack later but for now - it follows last in first out order or "LIFO", which means whenever a value or data comes in stack first it's going to be the last one to get out. Visualize it with stack of plates, the first plate we put is the last one there in the stack and the most upper one is last plate we've put there and will be the first one to get out. Phew !! that was a mouthfull.<br>
We can visualize more with the help of this example.
```bash

  |             |
  |    Stack    |  Higher Memory Addresses
  |             |
  +-------------+
  | Stack Frame |  <- Top of the stack (SP points here)
  | (Function   |
  |  Call #3)   |
  +-------------+
  | Stack Frame |  <- Previous function call
  | (Function   |
  |  Call #2)   |
  +-------------+
  | Stack Frame |  <- Initial function call
  | (Function   |
  |  Call #1)   |
  +-------------+
  |             |
  |  Free       |  Lower Memory Addresses
  |  Memory     |
  |             |

```

## CPU
CPU or central processing unit is the main working unit performing all the logical and physical tasks for us. CPU manages all the task as we know and typically consists of - 
- Register : The Registers are the CPU's storage. Registers are generally much smaller than the Main Memory, which is outside the CPU, and help save time in executing instructions by placing important data in direct access to the CPU.

- ALU Unit (Arithmetic and Logic Unit) : The arithmetic logic unit executes the instruction fetched from the Memory. The results of the executed instruction are then stored in either the Registers or the Memory.

- Control Unit (CU) : The Control Unit gets instructions from the main memory, depicted here outside the CPU. The address to the next instruction to execute is stored in a register called the Instruction Pointer or IP. <br>

This was a breif overview of inside of the CPU just to get and idea of what we're deealing with, now we will somewhat deep dive into...... Let's just get into it before i start getting off the topic again.

### RISC vs. CISC Architectures
< After you read [Instructions](#instructions) sections come back here and you will understand even more. ><br>

In the world of computer architecture, two primary design philosophies have dominated the landscape: RISC (Reduced Instruction Set Computer) and CISC (Complex Instruction Set Computer).(Woah!!) Let's explore each one of them, and I bet you're going to hear these names quite frequently. 

#### RISC Architecture

**Key Characteristics:**
- Simplicity: RISC architectures prioritize simplicity by using a smaller set of simple and frequently executed instructions.
- Fixed Instruction Length: RISC instructions typically have a fixed length, making decoding and execution more straightforward.
- Load-Store Architecture: Data manipulation instructions operate on registers, and memory access is primarily through load and store instructions.
- Pipelining: RISC processors often feature pipelining, allowing multiple instructions to be in various stages of execution simultaneously.
- Compiler-Friendly: RISC architectures are designed with compiler optimization in mind, making them well-suited for high-level language compilation.

**Advantages:**
- Predictable Execution Time: Due to a simpler instruction set and fixed instruction lengths, RISC processors often provide more predictable execution times.
- Energy Efficiency: RISC processors tend to be more power-efficient due to simplified execution units.
- Scalability: RISC designs are easily scalable, making them suitable for various applications, from embedded systems to high-performance computing.

#### CISC Architecture

**Key Characteristics:**
- Rich Instruction Set: CISC architectures feature a rich and diverse set of instructions, some of which perform complex operations.
- Variable Instruction Length: CISC instructions can vary in length, potentially complicating decoding and execution.
- Memory Access: CISC processors often allow memory access directly from memory to registers or vice versa, reducing the need for explicit load and store instructions.
- Microcoding: Complex instructions are often implemented as sequences of simpler microinstructions in the microcode.
- Emphasis on Hardware: CISC architectures rely on the hardware to handle complex operations.

**Advantages:**
- Fewer Instructions per Program: CISC processors can perform complex tasks in fewer instructions, potentially reducing the size of programs.
- Less Instruction Fetch Overhead: The larger instruction set can reduce the need for frequent instruction fetching.
- Legacy Support: CISC architectures are often backward compatible with older CISC designs, ensuring legacy software can still run.

### Why named as x86 ?
In 1978 Intel introduced it's most famous 8086 processor, which was the first processor which had it's own instruction set which now is refered as **x86**. When introduced it was a 16 bit microprocessor which uses [CISC](#risc-vs-cisc-architectures) Instruction Set and was have little endian notation. The x86 architecture gained popularity because of it's own instruction set and when IBM decided to include this processor as their default microprocessor to use in their PCs.<br>
Since then, the x86 architecture has evolved further in the x86-64 (or x64) architecture, which added 64-bit support while maintaining compatibility with 32-bit x86 software. This architecture has become the standard for modern personal computers and servers, offering both 32-bit and 64-bit execution modes.


### Registers
Registers are like small storage devices but with very fast processing speed. They can be considered as a part of CPU and are used by CPU to temporary store data in them which further can be fetched or rewrited. Unlike the main memory which are relatively a lot slower than registers these are faster and are of different types, where each register have it's own purpose for which it's defined for and is used by the cpu for a more organizable approach.

#### Types of Registers
1. **General Purpose Registers** : An x86 CPU has "**Eight**" 32-bit general purpose registers. x86-64 registers behave similarly to other architectures. A key component of x86-64 registers is multi-sized access which means the register RAX can have its lower 32 bits accessed with EAX (Extended Accumulator Register, ig you do know now why the word Extended is used). The next lower 16 bits can be accessed with AX and the lowest 8 bits can be accessed with AL which allows for the compuler to make optimizations which boost program execution.
![Register-Arch](/assets/BlogImages/Different-stor-registers.png)
<small>source - CTF101</small><br>

We will see use of these different capacity registers in x86 assembly programming. Now let's take a look at types of general purpose registers.
General purpose registers -  
- **EAX** : The accululator, some articles mentions that it's job is to store the return value but it's not just limited to that, infact the accumulator many a times referred as a main registers, it's used as an operand in many arithmetic operations, it's also used to hold data during an operation and it's also used to store data returned by a function many a times.
- **EBX** : EBX or the Extended Base Register, it's primary role is not defined hence it can be used for various purposes. allowing you to use it according to the needs of your program. But generally it's often is used as the base register for memory addressing.
- **ECX** : ECX or Extended Counter Register as the name suggest is used whenever there's a need of taking count of something for example during loops, or during arithmetic operations etc.
- **EDX** : EDX or Extended Data Register, almost same like ECX for storing temporary variable values or parameter values.
- **ESI** : ESI or Extended Source Index Register, as the name suggests is used as an index pointer for source data and by that I mean for ex during reading or writing of data from a "source" location in memory ESI is used.
- **EDI** : EDI or Extended Destination Index, serves the same purpose as ESI but for destination data, and by that i mean it's often used when we've to write data to destination location in memory.
- **EIP** : EIP or Extended Instruction Pointer, points to the memory address of the next instruction to be executed. It is fundamental for controlling program flow and determining the next instruction.

**[EBP and ESP](#instructions) both are a type of reserved pointers, we will discuss more about them later in this article.**

2. **EFLAG Registers** : E-Flag register or just Flag registers provide information about the results of arithmetic and logical operations, as well as other CPU state information. You will understand about them more clearly once you start using them, untill then here's a brief introduction on different types of flag registers.

- **CF** : Carry flag register is set to 1 if an operation generates a carry during addition or a borrow during subtraction or any in any other operation. Otherwise, it is cleared (or zero).
- **ZF** : ZF or Zero flag, Set to 1 if the result of an operation is zero; otherwise, it is cleared (set to 0).
- **PF** : PF or Parity flag, Set to 1 if the number of set bits in the result is even; otherwise, it is cleared or when the bits is odd.
- **SF** :SF or Sign flag, It indicates whether the result is negative (1) or non-negative (0).
- **DF** : DF or Direction flag, If set, string operations will decrement their pointer rather than incrementing it, reading memory backwards. (Will discuss more about it later in this article.)
- **OF** : OF or Overflow flag, as the name suggest if the bit gets overflow from it's assigned range or memory.
- **IF** : IF or interrupt flag, set to 1 if any interrupt is generated (by any hardware or software.)
- **TF** : TF or Trap flag, causes the CPU to enter single-step mode, where it executes one instruction at a time, useful for debugging.

**[Checkpoint Reached](#)**: Now i know that's a lot to take in at once. Let me make it easier for you, you don't have to remember all of that Think of it as your introduction to different types of registers. Once you begin programming with them and get used to their functions, you'll find that you remember most of it over time.

### Instructions
Instructions are specific commands that tells the CPU what operations to perform, where each instruction corresponds to a particular operation or action that the CPU can execute. So an instruction consists of Opcode, Operands, Addressing Mode, Size or data and so on. There are generally two ways we can write instructions in 1. Intel syntax and the 2. AT&T syntax and both just differs in a way such that in AT&T syntax, the source register is on the left side and the destination register is on the right side while it is the opposite for the Intel syntax. For example if there is 2 numbers present in register eax and ebx than the instruction - <br>

**add eax,ebx** will add both registers data and will store it in accumulator. <br>
Let's take a look at some of the frequently used common Instructions -

#### Arithmetic & Logic Instructions

- **mov and lea( load effective address)** :  They both are used to move data from one register or memory address to elsewhere, the difference being where the mov instruction is used to move data from one location to another and it can copy data between registers, memory locations, and immediate values whereas **lea**  is used to load the effective address of a memory location into a register. It first calculates the addresss from where the data is stored than transfers it. Let's take an example to get a more clearer idea -<br>
```bash
mov eax, ebx ;- copies the value of ebx registers and stores it in eax register.
mov eax, 0x8773493437 ; - copies the value of data stored at that memory address and stores it in eax register.
```
OR
```bash
lea eax, [ebx+4] ; - Computes the address of ebx + 4 (adding 4 to the value in ebx) and stores it in the eax register.
lea edi, [esi + ecx*2]: Calculates the address of esi + ecx*2 and stores it in the edi register.
```
[Why](#) the closed squar brackets [ ] in lea instructions ? Let's say there's a value 5 stored at location ebx+4 and if we write 
```bash
lea eax, [ebx+4]
```
instead of value stored at that address, the address will get stored in the accumulator. We can relate this concept with c programming where if we just write the pointer value it will output the address it's pointing to instead of the value stored at that address. So to get the value stored at that location we've to write it in square brackets[ ].

- **add and sub** : As the name suggests these instructions are used to either add a value store in register and a given input, or to add two values from different registers and stores the results in the first argument.
ex - 
```bash
; Semicolon is used for comments in assembly.
add eax, 0x7 ; 7 is added with value stored at eax and the result is stored in eax.
```
Something similar with sub instruction too, second argument gets substracted with the first one and result is stored in the first one.

- **or and xor** : The "or" instruction performs a bitwise OR operation between two operands and stores the result in a first operand, same can be said for xor instruction with bitwise xor operation.

#### Control Flow or Stack based Instructions - 

- **push & pop** : as the name suggests and discussed earlier, push instruction put whatever has been given to it, to the top of the stack. Syntax is simple : push < arg > . ESP pointer is the pointer which points at the top of the stack, where the next item will be pushed in the stack, so whenever the push instruction is used esp is move upwards and is used to determine the location to which the data is being pushed into and for pop instruction exactly opposite happens.

- **call** : call instruction is used to call a function in a program or library using it's address. The syntax is as follows - <br>
**call < func_address >**
So when a function is called the return address ( or where it have to return to the program when the function call ends ) is pushed into the stack, and then it can return to the caller itself. Basically when a function is called all of the current parameter which are essential for the program are pushed into the stack called as "Stack frame", so that when the function execution completes it can return to it's base address and continue it's flow.

- **leave & ret** : The leave instruction is used to clean up the stack frame of the current function and prepare for returning to the calling function, whereas The ret instruction is used to return from a function to the calling function. It's often followed by an optional operand that specifies the number of bytes to add to the stack pointer, effectively deallocating local variables and function parameters from the stack. Often both of them are used together ret after leave statement where the leave performs the cleanup and ret gets back to the calling function, hence stack is again started with the previous address of eip stored in the stack.

- **jmp** : the jump statement allows us to unconditionally transfer program control to a specified destination, which can be a label, a memory address, or a register value and it can be done by specifying certain conditional jump as well.
for example - je(jump if equal), jz (jump if zero ), jl (jump if less), jg (jump if greater ). Jump statement generally are used to create loops, or to create conditional statements, or conditional loops. Let's take an example to understand it's syntax as well.<br>
We're going to make a simple loop which will start from zero and will run untill the register is incremented to 8. We're assuming the accumulator has value 0.

```bash
loop_start: 
                 
    add eax,0x1  ; loop_start is just a label which we can use to tell the jump statement where it has to jump if certain condition is satisfied.
    cmp ecx, 0x8 ; After comparing both of them, if the result is not true zero flag would be set to 1 indicating not equal.
    jnz start    ; jnz will look if the previous operation's result was successfull (zero) or not, if not the loop starts again.

```

What's happening here is let's start from 0, 1 is added to eax (i.e 0 ) and eax now contains 1. cmp checks if the eax and 0x8 value are equal or not. If they're not the loop start again and the accumulator value keeps updating unless it's equal to 8 and then the zero flag is set after cmp statement and the loop exits.

Now as you've read the instruction sections you can understand more clearly what [risc and cisc architecture ](#risc-vs-cisc-architectures) really is.
So do you remember for adding two numbers we just use add reg1, reg2 and the numbers get add automatically and gets stores in the reg1 ? Yes thats what CISC architecture is - consists of many instructions set for various functionalitiy whereas to add 2 number in RISC architecture what we've to do is - 

```bash 

    ldr r0, =num1    ; Load address of num1 into r0
    ldr r1, [r0]     ; Load num1 into r1

    ldr r0, =num2    ; Load address of num2 into r0
    ldr r2, [r0]     ; Load num2 into r2

    ; Perform addition
    add r3, r1, r2   ; Add r1 and r2, result in r3

    ; Store the result
    ldr r0, =result  ; Load address of result into r0
    str r3, [r0]     ; Store the result in 'result'

    ; Exit (for demonstration purposes)
    mov r7, #1        ; Exit system call number
    swi 0             ; Make the system call (for ARM on Linux)

    ; End of program

```
I think now you can understand CISC vs RISC architecture better with this understanding in your mind.<br>
** The End of the THEORY Section !! **

---

# Labs

**Drum Rolls Please !!!!!!!!**<br>
Now, let's begin writing code that will help us familiarize more with this language and will give us a one more reason to question our existence.

## Hello World
Let's start with our first program, As every other programmer or coder in this world our first program in assembly language would be to print "Hello world !", we will start with making a file in terminal and will name it as hello_world.asm - 
### Begineer
**I. Hello World**<br> The first program we're going to built is ofcourse the one above all !! "Hello World !!".

```bash
$ touch hello_world.asm
```
I'll be using vim for writing this code but you can choose whatever you like.
```bash
$ vim hello_world.asm
```
So starting the program we've to mention the section we're keyword and specify which section we're creating and using here.
the first one here is .text for storing our code, also this is where generally payloads are stored in many malware and .data will be used to store certain variables here. So as our first assembly language we'll be writing hello world in it.

```bash
section .data :
    message db "Hello world !", 0 ; db is used to define character strings and 0 is used to end string with null char.
    message_length: 12 ; 

section .text :
global _start

_start:
    ; In the .text section we've declare an entry point _start to where the actual execution begins.
    mov eax, 0x4 ; In x86 to make system call we have to assign a number to accumulator and to call write function it's 4.
    mov ebx, 0x1 ; ebx is set to 1 to represent stdout (standard output).
    mov ecx, message ; assigning pointer to our variable to know where to start.
    mov edx, message_length ; assigning each parameter to a register so that it can be used during execution.

; Now making the system call.
    int 0x80 ; int stands for interrupt so making an interrupt to invoke kernal i.e 0x80, which will write o/p to stdout.

; Now exiting the porgarm by making system call for sys_exit
    mov eax, 1 ; 1 is the system call for sys_exit.
    mov ebx, 0 ; setting the status of the program to zero, specifying it runned successfully.
    int 0x80 ; Again making the system call to kernal which will usse sys_exit, with exit status 0.

; And voilla ! We've written our first "Hello World" program in assembly language.
```
Now to run this progarm we will use commad - 
```bash
$ nasm -f elf32 -o hello_world.o hello_world.asm
```
Collecting object code <br>
```bash
$ ld -m elf_i386 -o hello_world hello_world.o
```
And now it's finally time to run our first assembly program.
```bash
$ ./hello_world

$ Hello World !
```
Finally we've made our first assembly program of hello world !. You can no continue your journey to elsewhere or can go further level it's upto you. To you traveller !! .
<br><br>

**II. Converting a integer into ASCII Representation.** <br>
The next program we're going to do is Converting integer into it's ascii representation so that we can print it in the output screen. It's quite complex program but we'll learn a lot from this.

As usual we will start with creating a file called convascii.asm
```bash
$ touch convascii.asm
```
and as usual will start coding in the vim environment.
```bash
$ vim convascii.asm
```
Now let's discuss the logic first. What we're going to do is making a loop in which we'll constantly divide the number with 10, and dividing the number with 10 gives the last digit as the remainder in output. In that way we will get the last digit of the number and we will convert that digit to ascii first and will merge with the remaining one but we've to do this in reverse loop so that we get the same string instead of the reverse one.
<br>
A moment of reflection, this particular task has occupied a significant portion of my time! It's difficult to articulate why it demanded so much of my attention, but regardless, the effort invested was entirely worth it !

```bash
section .data
    integer dd 53483    ; random integer to convert it into it's ascii form.
    output  db 40       ; Buffer for the ASCII representation 

section .text
global _start

_start:
    ; Load the integer into EAX
    mov eax, [integer]

    ; Set EDI to point to the end of the buffer

    mov edi, output + 39  ; Moving the pointer to point at the end of the buffer as the buffer is of length 40.
                          ; Start from the end and move backward

    ; Null-terminate the buffer
    mov byte [edi], 0

convertLoop:

    ; Dividing EAX by 10, recall the logic discussed previously.

    mov edx, 0     ; Clearing the register as it may contain any previous remainder.
    mov ecx, 10      ; Set divisor to 10
    div ecx          ; Divide ecx by 10, result in EAX and remainder in edx.

    ; Converting the remainder to ASCII and storing it in the buffer.

    add dl, '0'      ; Convert remainder to ASCII character
    dec edi          ; Move buffer pointer backward
    mov [edi], dl    ; Store the ASCII character in the buffer, here dl is the lower bits of edx register. 
                     ; We're not using edx because then the '0's ascii value will be added to whole register and will output something else.
    
    ; Now Checking if quotient (EAX) is zero or not.

    cmp eax, eax ; cmp will not set zero flag if they both are equal otherwise 1.

    jnz convertLoop  ; If not zero, continue the loop, which means that the numeber is not finished yet.

    ; Now to calculate the length of the ASCII representation first we'll get the value of current edi, move it to eax and will calculate how much it is from output, hence getting the length of output.
    mov eax, edi      ; Set eax to the address of the last character
    sub eax, output   ; Calculate the offset from the start of the buffer
    inc eax           ; Include the null terminator

    ; Prepare the output string, ig you can do this part on your own finally !!!.
    mov eax, 4           ; syscall number for sys_write
    mov ebx, 1           ; file descriptor (stdout)
    mov ecx, edi         ; pointer to the ASCII representation in the buffer
    mov edx, 40          ; fixed length of the message (including potential leading zeros)
    
    ; Make the write system call to display the message and ASCII representation
    int 0x80

    ; Exit the program
    mov eax, 1       ; syscall number for sys_exit
    xor ebx, ebx     ; exit status 0
    int 0x80

```
**Output** - 

```bash
$ nasm -f elf32 -o convascii.o convascii.asm
```
Collecting object code <br>
```bash
$ ld -m elf_i386 -o convascii convascii.o
```
And now it's finally time to run our mine most time consuming assembly program ...
```bash
$ ./convascii

$ 12345
```
**I'm not crying you're crying !!**
<br><br>

**III. Finding Modulus of a Number** <br>
The next program we're going to do is finding modulus of a number. I request you to try it yourself first and then move further.
As usual we will start with creating a file called mod.asm
```bash
$ touch mod.asm
```
and as usual will start coding in the vim environment.
```bash
$ vim mod.asm
```
And now finally the code - 
```bash
section .data
    divident dd 17 ; Just for example we're taking divident as 17.
    divisor dd 5 ; Taking divisor that can give us some remainder.
    result db "Modulus ", 0 ;

section .bss
    ; .bss sections is used for declaring uninitalized variables.
    output resb 32  ; Declaring a variable to store our output modulus result, resb represents to allocate 32 bit as buffer.

section .text
global _start

_start:
    mov eax, [divident] ; Remember the concept of square brackets ?
    move ebx, [divisor] ; 
    div ebx ; div instruction divides the register with accumulator and stores the result in edx.
    mov eax, edx ; The remainder is moved in the accumulator.

    ; Now for displaying the result we've to convert our register's data into ascii form.
    ; for that we'll be creating a function called itoa, it's just like any other label but we're naming it here function.

    mov edi, output ; allocating a pointer to the output variable to keep track of our variable.
    call conversion

    ; Prepare the output string
    mov eax, 4        ; syscall number for sys_write
    mov ebx, 1        ; file descriptor (stdout)
    mov ecx, result   ; message to display
    mov edx, edi      ; length of the message
    int 0x80

    ; Exit the program
    mov eax, 1        ; syscall number for sys_exit
    xor ebx, ebx      ; exit status 0
    int 0x80

conversion:
    ; for reference ebx is storing divisor, ecx is storing 

    ; Integer to ASCII conversion function (EDX=input, EDI=output)
    push ebx
    push ecx
    push edx

    mov ecx, 10       ; Set divisor to 10 (for decimal conversion)
    mov ebx, edi      ; Point ebx to the end of the output buffer

reverseLoop:
    xor edx, edx      ; Clear any previous remainder
    div ecx           ; Divide EDX:EAX by 10, result in EAX, remainder in EDX
    add dl, '0'       ; Convert remainder to ASCII
    dec ebx           ; Move buffer pointer backwards
    mov [ebx], dl     ; Store ASCII character in the buffer
    test eax, eax     ; Check if quotient is zero
    jnz reverseLoop   ; If not, continue loop

    mov edi, ebx      ; Set edi to point to the beginning of the string

    pop edx
    pop ecx
    pop ebx
    ret



```
**Output** - 

```bash
$ nasm -f elf32 -o mod.o mod.asm
```
Collecting object code <br>
```bash
$ ld -m elf_i386 -o mod mod.o
```
And now it's finally time to run our  assembly program ...
```bash
$ ./mod

$ Modulus 2
```
**Is there anything I can be more grateful for than the present moment?!**
<br><br>

**IV. Even Number Identifier** <br>
Let's take it a step further, the next program we're going to do is even number identifier. I request you to try it yourself first and then move further.
As usual we will start with creating a file called even_odd.asm
```bash
$ touch even_odd.asm
```
and as usual will start coding in the vim environment.
```bash
$ vim even_odd.asm
```
Now before writing the program let's explore the logic we're going to apply. There are two ways to do this program i suggest you to prefer the hard one. The first one is just identify the LSB of the number and if it's zero the number is even otherwise odd. It's pretty simple and you just have to use test instruction **< Do some research on your own for this one >**. Now in the second one to detect if the number is even or not, we have to find it's modulus.... Oh! wait we've done it before !!??, my goooood!! iska matlab samjhe daya ??.<br>
Try it on your own, i'm just providing the final code for the first section which you can use to compare with your code or if you're stuck somewhere and require a reference, here you go.
```bash
section .data
    evenMsg db "The number is even.", 0
    oddMsg db "The number is odd.", 0

section .text
global _start

_start:
    mov eax, 42 ; Replace with your number
    test eax, 1
    jz isEven

    ; Code for odd number
    mov ebx, oddMsg
    jmp printMessage

isEven:
    ; Code for even number
    mov ebx, evenMsg

printMessage:
    mov eax, 4
    mov ecx, ebx
    mov edx, 20 ; Adjust the message length as needed
    int 0x80

    ; Exit the program
    mov eax, 1
    xor ebx, ebx
    int 0x80


```

### Intermediate
In the Intermediate section we will start directly from making a calculator program that takes input from the user what it has to perform addition, subs, multiplication or division and then based on that it performs it's defined action.
As usual we'll start by creating file but this time i would recommend you all to first try to create this program by yourself.
<br> On that note - 

```bash
$ touch calc.asm
```

We will start the editing in our vim editor.

```bash
$ vim calc.asm
```
**V.** **Calculator Program in Assembly**
```bash
section .data 
    buffer db 20 ; buffer to store the input.
    buf_len equ $ - buffer ; Calculating the length of the buffer.
    prompt db "Enter your choice :", 0xA, "1. Add", 0xA, "2. Sub", 0xA, "3. Multiply", 0xA, "4. Divide", 0 ; 0xA represent newline character in your ass.
    input1 db "Enter first variable : ", 0
    input2 db "Enter second variable : ", 0
    inp1_len equ $ - input1
    inp2_len equ $ - input2
    prompt_len equ $ - prompt
    result db "Answer ", 0 ;

section .bss 
    choice resd 1 ; reserved space for the integer choice input.
    inp1 resd 32 ; input 1 for operation.
    inp2 resd 32 ; input 2 for further operation.
    outis resd 32


section .text
global _start


_start:
    ; The first step being displaying options and asking user to enter their choice.
    mov eax, 4
    mov ebx, 1
    mov ecx, prompt
    mov edx, prompt_len
    int 0x80

    ; Now reading input1 from the user.
    mov eax, 3 ; syscall number for sys_read
    mov ebx, 0 ; file descriptor (stdin)
    mov ecx, buffer
    mov edx, buf_len
    int 0x80

    ; Now converting the input string to an integer.

    mov eax, buffer ; Getting the address of the input string.
    call str2int ; Calling our function that can convert string to integer.
    mov [choice], eax ; storing the integer value in the choice variable.

    ; As our choice is stored in the choice variable now we will start with taking input for both of them. 
    ; Taking input for variable inp1
    
    mov eax, 4
    mov ebx, 1
    mov ecx, input1
    mov edx, inp1_len
    int 0x80

    ; Reading the first input.
    mov eax, 3
    mov ebx, 0
    mov ecx, buffer
    mov edx, buf_len
    int 0x80

    ; Same converting string into integer.
    mov eax, buffer
    call str2int
    mov [inp1], eax 

    ; Taking input for second variable.
    mov eax, 4
    mov ebx, 1
    mov ecx, input2
    mov edx, inp2_len
    int 0x80

    ; Reading the second input.
    mov eax, 3
    mov ebx, 0
    mov ecx, buffer
    mov edx, buf_len
    int 0x80

    ; Same converting string into integer.
    mov eax, buffer
    call str2int
    mov [inp2], eax 


    ; Making Labels for Arithmetic operations.
    mov eax, 1
    cmp eax, choice
    jz addition

    mov eax, 2
    cmp eax, choice
    jz subtraction

    mov eax, 3
    cmp eax, choice
    jz multiply

    mov eax, 4
    cmp eax, choice
    jz divide

addition:
    mov eax, inp1
    add eax, [inp2]
    mov [outis], eax
    mov edi, outis ; allocating a pointer to the output variable to keep track of our variable.
    call conversion
    jmp output


substraction:
    mov eax, inp1
    sub eax, inp2
    mov [outis], eax
    mov edi, outis ; allocating a pointer to the output variable to keep track of our variable.
    call conversion
    jmp output


multiply:
    mov eax, inp1
    mul dword [inp2]
    mov [outis], eax
    mov edi, outis ; allocating a pointer to the output variable to keep track of our variable.
    call conversion
    jmp output


divide:
    mov eax, inp1
    div inp2
    mov [outis], eax
    mov edi, outis ; allocating a pointer to the output variable to keep track of our variable.
    call conversion
    jmp output

; Now defining our functions.

; Converting Integer into String variable for ascii. IG you can now do this on your own.

conversion:
    ; for reference ebx is storing divisor, ecx is storing 

    ; Integer to ASCII conversion function (EDX=input, EDI=output)
    push ebx
    push ecx
    push edx

    mov ecx, 10       ; Set divisor to 10 (for decimal conversion)
    mov ebx, edi      ; Point ebx to the end of the output buffer

reverseLoop:
    xor edx, edx      ; Clear any previous remainder
    div ecx           ; Divide EDX:EAX by 10, result in EAX, remainder in EDX
    add dl, '0'       ; Convert remainder to ASCII
    dec ebx           ; Move buffer pointer backwards
    mov [ebx], dl     ; Store ASCII character in the buffer
    test eax, eax     ; Check if quotient is zero
    jnz reverseLoop   ; If not, continue loop

    mov edi, ebx      ; Set edi to point to the beginning of the string

    pop edx
    pop ecx
    pop ebx
    ret


; Converting String to Integer.

str2int:
    pushad ; Basically or general purpose registers are pushed into the stack so that they can be used later.
    mov eax, 0
    mov ecx, 0

char_loop:
    ; were going to convert each char of string into integer, why ? to use this function later as well.
    ; Generally ascii char are of 8 bits so to store them in register were moving them with movzx to extend its bit.

    movzx edx, byte[edi + ecx] ; movzx takes the char byte and after setting remaining bites zero moves it to greater bytes register.
  
    ; At first section we point edi towards the end section of the output, now you know why we did that.
    ; Why edi + ecx ? basically its used for address calculation, a common practice youll see very often.

    test dl, dl ; again were dealing with 8 bytes of data so instead of edx were just using dl, and it tests if null is set.
    jz done ; If theyre the zero flag will be set hence jump.

    ; In test dl, dl were checking if its null terminated string or not. If it is jump to done section.

    sub dl, '0'
    
    imul eax, eax, 10 ; imul is used to mulitply registers with some value, here were multiplying it by 10 and storing in eax.
  
    ; When the char is converted into digit, say in 12345 its 1, we multiply the value stored with 10 so 0*10 = 0, and now 
    ; it contains 1. When the next digit i.e 2 came, the result stored is 1 we multiply it with 10 and adds2 so we get 
    ; 1*10 +2 = 12. Now for the next digit 3, we multiply the 12 with 10 and adds 3, so 120 + 3 i.e 123 and the process is repeated
    ; to get our full integer. Its just like what we do in C/C++ programming but with interacting directly with registers.
   
    add eax, edx 
    inc ecx
    jmp char_loop

done:
    popad ; Restoring our original data registers before the conversion process.
    ret

    ; Now will output for the final output.
    ; Prepare the output string

output:
    mov eax, 4        ; syscall number for sys_write
    mov ebx, 1        ; file descriptor (stdout)
    mov ecx, result   ; message to display
    mov edx, edi      ; length of the message
    int 0x80


    ; Exit the program
    mov eax, 1        ; syscall number for sys_exit
    xor ebx, ebx      ; exit status 0
    int 0x80

```
<br>

**VI.** **Making this patter in assembly language. ( I swear this is the last one, promise !!!)** 



### Advance
Honestly, I've covered a lot of advanced topics in assembly, and for now, it might be beyond my current capabilities. I believe this should give you a strong start in your journey into reverse engineering and exploring x86 assembly language and now you are capable enough to travel alone from here my fellow adventurer !!!.

---

# ADIOS !!