---
# layout: post
title:  "x86 Assembly, What the hell is it ?"
tags: ["Reverse Engineering", "x86 Assembly", "Binary", "Assembly"]
---

# Theory
x86 Assembly 101 consists of two main components: the Theory section, which covers all the essential theoretical concepts necessary to finally able to question ourselves and our existence, and the Labs section. In the Labs, we will learn hands-on demonstrations of the theory weâ€™ve learned and follow step-by-step tutorials for getting started.

## Introduction
This blog is for those who wants to get an idea or wants to get started in learning assembly language or can be helpful in their RE journey as well. I too am learning parellely with writing this blog so don't mind if i've oversimplified something or have said something too generic. I have plans to cover up those generic topic as well but have to complete this first. I've stated this previosuly many times in my blogs and i'm telling it again that **"I consider myself a beginner in everything, and I'll stay that way until I achieve something significant in this field."**. <br>
Before diving into what x86 assembly is, what does x86 mean, what other different types of architcture are, we will cover up the basics first starting from all the way back to ........... CPU Architecure.

## CPU
CPU or central processing unit is the main working unit performing all the logical and physical tasks for us. CPU manages all the task as we know and typically consists of - 
- Register : The Registers are the CPU's storage. Registers are generally much smaller than the Main Memory, which is outside the CPU, and help save time in executing instructions by placing important data in direct access to the CPU.

- ALU Unit (Arithmetic and Logic Unit) : The arithmetic logic unit executes the instruction fetched from the Memory. The results of the executed instruction are then stored in either the Registers or the Memory.

- Control Unit (CU) : The Control Unit gets instructions from the main memory, depicted here outside the CPU. The address to the next instruction to execute is stored in a register called the Instruction Pointer or IP. <br>

This was a breif overview of inside of the CPU just to get and idea of what we're deealing with, now we will somewhat deep dive into...... Let's just get into it before i start getting off the topic again.

### Registers
Registers are like small storage devices but with very fast processing speed. They can be considered as a part of CPU and are used by CPU to temporary store data in them which further can be fetched or rewrited. Unlike the main memory which are relatively a lot slower than registers these are faster and are of different types, where each register have it's own purpose for which it's defined for and is used by the cpu for a more organizable approach.

#### Types of Registers
1. **General Purpose Registers** : An x86 CPU has "**Eight**" 32-bit general purpose registers. x86-64 registers behave similarly to other architectures. A key component of x86-64 registers is multi-sized access which means the register RAX can have its lower 32 bits accessed with EAX (Extended Accumulator Register, ig you do know now why the word Extended is used). The next lower 16 bits can be accessed with AX and the lowest 8 bits can be accessed with AL which allows for the compuler to make optimizations which boost program execution.
![Register-Arch](/assets/BlogImages/Different-stor-registers.png)
<small>source - CTF101</small><br>

We will see use of these different capacity registers in x86 assembly programming. Now let's take a look at types of general purpose registers.
General purpose registers -  
- **EAX** : The accululator, some articles mentions that it's job is to store the return value but it's not just limited to that, infact the accumulator many a times referred as a main registers, it's used as an operand in many arithmetic operations, it's also used to hold data during an operation and it's also used to store data returned by a function many a times.
- **EBX** : EBX or the Extended Base Register, it's primary role is not defined hence it can be used for various purposes. allowing you to use it according to the needs of your program. But generally it's often is used as the base register for memory addressing.
- **ECX** : ECX or Extended Counter Register as the name suggest is used whenever there's a need of taking count of something for example during loops, or during arithmetic operations etc.
- **EDX** : EDX or Extended Data Register, almost same like ECX for storing temporary variable values or parameter values.
- **ESI** : ESI or Extended Source Index Register, as the name suggests is used as an index pointer for source data and by that I mean for ex during reading or writing of data from a "source" location in memory ESI is used.
- **EDI** : EDI or Extended Destination Index, serves the same purpose as ESI but for destination data, and by that i mean it's often used when we've to write data to destination location in memory.
- **EIP** : EIP or Extended Instruction Pointer, points to the memory address of the next instruction to be executed. It is fundamental for controlling program flow and determining the next instruction.

**EBP and ESP both are a type of reserved pointers, we will discuss more about them later in this article.**

2. **EFLAG Registers** : E-Flag register or just Flag registers provide information about the results of arithmetic and logical operations, as well as other CPU state information. You will understand about them more clearly once you start using them, untill then here's a brief introduction on different types of flag registers.

- **CF** : Carry flag register is set to 1 if an operation generates a carry during addition or a borrow during subtraction or any in any other operation. Otherwise, it is cleared (or zero).
- **ZF** : ZF or Zero flag, Set to 1 if the result of an operation is zero; otherwise, it is cleared (set to 0).
- **PF** : PF or Parity flag, Set to 1 if the number of set bits in the result is even; otherwise, it is cleared or when the bits is odd.
- **SF** :SF or Sign flag, It indicates whether the result is negative (1) or non-negative (0).
- **DF** : DF or Direction flag, If set, string operations will decrement their pointer rather than incrementing it, reading memory backwards. (Will discuss more about it later in this article.)
- **OF** : OF or Overflow flag, as the name suggest if the bit gets overflow from it's assigned range or memory.
- **IF** : IF or interrupt flag, set to 1 if any interrupt is generated (by any hardware or software.)
- **TF** : TF or Trap flag, causes the CPU to enter single-step mode, where it executes one instruction at a time, useful for debugging.

### RISC vs. CISC Architectures

In the world of computer architecture, two primary design philosophies have dominated the landscape: RISC (Reduced Instruction Set Computer) and CISC (Complex Instruction Set Computer).(Woah!!) Let's explore each one of them, and I bet you're going to hear these names quite frequently.

#### RISC Architecture

**Key Characteristics:**
- Simplicity: RISC architectures prioritize simplicity by using a smaller set of simple and frequently executed instructions.
- Fixed Instruction Length: RISC instructions typically have a fixed length, making decoding and execution more straightforward.
- Load-Store Architecture: Data manipulation instructions operate on registers, and memory access is primarily through load and store instructions.
- Pipelining: RISC processors often feature pipelining, allowing multiple instructions to be in various stages of execution simultaneously.
- Compiler-Friendly: RISC architectures are designed with compiler optimization in mind, making them well-suited for high-level language compilation.

**Advantages:**
- Predictable Execution Time: Due to a simpler instruction set and fixed instruction lengths, RISC processors often provide more predictable execution times.
- Energy Efficiency: RISC processors tend to be more power-efficient due to simplified execution units.
- Scalability: RISC designs are easily scalable, making them suitable for various applications, from embedded systems to high-performance computing.

#### CISC Architecture

**Key Characteristics:**
- Rich Instruction Set: CISC architectures feature a rich and diverse set of instructions, some of which perform complex operations.
- Variable Instruction Length: CISC instructions can vary in length, potentially complicating decoding and execution.
- Memory Access: CISC processors often allow memory access directly from memory to registers or vice versa, reducing the need for explicit load and store instructions.
- Microcoding: Complex instructions are often implemented as sequences of simpler microinstructions in the microcode.
- Emphasis on Hardware: CISC architectures rely on the hardware to handle complex operations.

**Advantages:**
- Fewer Instructions per Program: CISC processors can perform complex tasks in fewer instructions, potentially reducing the size of programs.
- Less Instruction Fetch Overhead: The larger instruction set can reduce the need for frequent instruction fetching.
- Legacy Support: CISC architectures are often backward compatible with older CISC designs, ensuring legacy software can still run.

### Why named as x86 ?
In 1978 Intel introduced it's most famous 8086 processor, which was the first processor which had it's own instruction set which now is refered as **x86**. When introduced it was a 16 bit microprocessor which uses [CISC](#risc-vs-cisc-architectures) Instruction Set and is have little endian notation. The x86 architecture gained popularity because of it's own instruction set and when IBM decided to include this processor as their default microprocessor to use in their PCs.<br>
Since then, the x86 architecture has evolved further, culminating in the x86-64 (or x64) architecture, which added 64-bit support while maintaining compatibility with 32-bit x86 software. This architecture has become the standard for modern personal computers and servers, offering both 32-bit and 64-bit execution modes.
